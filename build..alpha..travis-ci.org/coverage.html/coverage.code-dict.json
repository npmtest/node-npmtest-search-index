{"/home/travis/build/npmtest/node-npmtest-search-index/test.js":"/* istanbul instrument in package npmtest_search_index */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-search-index/lib.npmtest_search_index.js":"/* istanbul instrument in package npmtest_search_index */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_search_index = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_search_index = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-search-index/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-search-index && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_search_index */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_search_index\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_search_index.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_search_index.rollup.js'] =\n            local.assetsDict['/assets.npmtest_search_index.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_search_index.__dirname + '/lib.npmtest_search_index.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index/lib/index.js":"const bunyan = require('bunyan')\nconst level = require('levelup')\nconst down = require('leveldown')\nconst SearchIndexAdder = require('search-index-adder')\nconst SearchIndexSearcher = require('search-index-searcher')\n\nmodule.exports = function (givenOptions, moduleReady) {\n  const optionsLoaded = function (err, SearchIndex) {\n    const siUtil = require('./siUtil.js')(SearchIndex.options)\n    if (err) return moduleReady(err)\n    SearchIndex.close = siUtil.close\n    SearchIndex.countDocs = siUtil.countDocs\n    getAdder(SearchIndex, adderLoaded)\n  }\n\n  const adderLoaded = function (err, SearchIndex) {\n    if (err) return moduleReady(err)\n    getSearcher(SearchIndex, searcherLoaded)\n  }\n\n  const searcherLoaded = function (err, SearchIndex) {\n    if (err) return moduleReady(err)\n    return moduleReady(err, SearchIndex)\n  }\n\n  getOptions(givenOptions, optionsLoaded)\n}\n\nconst getAdder = function (SearchIndex, done) {\n  SearchIndexAdder(SearchIndex.options, function (err, searchIndexAdder) {\n    SearchIndex.add = searchIndexAdder.add\n    SearchIndex.callbackyAdd = searchIndexAdder.concurrentAdd  // deprecated\n    SearchIndex.concurrentAdd = searchIndexAdder.concurrentAdd\n    SearchIndex.createWriteStream = searchIndexAdder.createWriteStream\n    SearchIndex.dbWriteStream = searchIndexAdder.dbWriteStream\n    SearchIndex.defaultPipeline = searchIndexAdder.defaultPipeline\n    SearchIndex.del = searchIndexAdder.deleter\n    SearchIndex.deleteStream = searchIndexAdder.deleteStream\n    SearchIndex.flush = searchIndexAdder.flush\n    done(err, SearchIndex)\n  })\n}\n\nconst getSearcher = function (SearchIndex, done) {\n  SearchIndexSearcher(SearchIndex.options, function (err, searchIndexSearcher) {\n    SearchIndex.availableFields = searchIndexSearcher.availableFields\n    SearchIndex.buckets = searchIndexSearcher.bucketStream\n    SearchIndex.categorize = searchIndexSearcher.categoryStream\n    SearchIndex.classify = searchIndexSearcher.classify\n    SearchIndex.dbReadStream = searchIndexSearcher.dbReadStream\n    SearchIndex.get = searchIndexSearcher.get\n    SearchIndex.match = searchIndexSearcher.match\n    SearchIndex.scan = searchIndexSearcher.scan\n    SearchIndex.search = searchIndexSearcher.search\n    SearchIndex.totalHits = searchIndexSearcher.totalHits\n    done(err, SearchIndex)\n  })\n}\n\nconst getOptions = function (options, done) {\n  var SearchIndex = {}\n  SearchIndex.options = Object.assign({}, {\n    indexPath: 'si',\n    keySeparator: '￮',\n    logLevel: 'error'\n  }, options)\n  options.log = bunyan.createLogger({\n    name: 'search-index',\n    level: options.logLevel\n  })\n  if (!options.indexes) {\n    level(SearchIndex.options.indexPath || 'si', {\n      valueEncoding: 'json',\n      db: down\n    }, function (err, db) {\n      SearchIndex.options.indexes = db\n      return done(err, SearchIndex)\n    })\n  } else {\n    return done(null, SearchIndex)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-adder/index.js":"/*\nsearch-index-adder\n\nThe module that adds documents into search-index' can also be run as a\nstandalone\n\n*/\n\nconst DBEntries = require('./lib/delete.js').DBEntries\nconst DBWriteCleanStream = require('./lib/replicate.js').DBWriteCleanStream\nconst DBWriteMergeStream = require('./lib/replicate.js').DBWriteMergeStream\nconst DocVector = require('./lib/delete.js').DocVector\nconst IndexBatch = require('./lib/add.js').IndexBatch\nconst Readable = require('stream').Readable\nconst RecalibrateDB = require('./lib/delete.js').RecalibrateDB\nconst bunyan = require('bunyan')\nconst del = require('./lib/delete.js')\nconst docProc = require('docproc')\nconst leveldown = require('leveldown')\nconst levelup = require('levelup')\nconst pumpify = require('pumpify')\n\nconst async = require('async')\n\nmodule.exports = function (givenOptions, callback) {\n  getOptions(givenOptions, function (err, options) {\n    var Indexer = {}\n    Indexer.options = options\n\n    var q = async.queue(function (batch, callback) {\n      const s = new Readable({ objectMode: true })\n      batch.batch.forEach(function (doc) {\n        s.push(doc)\n      })\n      s.push(null)\n      s.pipe(Indexer.defaultPipeline(batch.batchOps))\n        .pipe(Indexer.add())\n        .on('data', function (data) {})\n        .on('end', function () {\n          return callback()\n        })\n        .on('error', function (err) {\n          return callback(err)\n        })\n    }, 1)\n\n    Indexer.add = function () {\n      return pumpify.obj(\n        new IndexBatch(Indexer),\n        new DBWriteMergeStream(options))\n    }\n\n    Indexer.concurrentAdd = function (batchOps, batch, done) {\n      q.push({\n        batch: batch,\n        batchOps: batchOps\n      }, function (err) {\n        done(err)\n      })\n    }\n\n    Indexer.close = function (callback) {\n      options.indexes.close(function (err) {\n        while (!options.indexes.isClosed()) {\n          options.log.debug('closing...')\n        }\n        if (options.indexes.isClosed()) {\n          options.log.debug('closed...')\n          callback(err)\n        }\n      })\n    }\n\n    Indexer.dbWriteStream = function (streamOps) {\n      streamOps = Object.assign({}, { merge: true }, streamOps)\n      if (streamOps.merge) {\n        return new DBWriteMergeStream(options)\n      } else {\n        return new DBWriteCleanStream(options)\n      }\n    }\n\n    Indexer.defaultPipeline = function (batchOptions) {\n      batchOptions = Object.assign({}, options, batchOptions)\n      return docProc.pipeline(batchOptions)\n    }\n\n    Indexer.deleteStream = function (options) {\n      return pumpify.obj(\n        new DocVector(options),\n        new DBEntries(options),\n        new RecalibrateDB(options)\n      )\n    }\n\n    Indexer.deleter = function (docIds, done) {\n      const s = new Readable()\n      docIds.forEach(function (docId) {\n        s.push(JSON.stringify(docId))\n      })\n      s.push(null)\n      s.pipe(Indexer.deleteStream(options))\n        .on('data', function () {\n          // nowt\n        })\n        .on('end', function () {\n          done(null)\n        })\n    }\n\n    Indexer.flush = function (APICallback) {\n      del.flush(options, function (err) {\n        return APICallback(err)\n      })\n    }\n\n    //  return Indexer\n    return callback(err, Indexer)\n  })\n}\n\nconst getOptions = function (options, done) {\n  options = Object.assign({}, {\n    deletable: true,\n    batchSize: 100000,\n    fieldedSearch: true,\n    fieldOptions: {},\n    preserveCase: false,\n    keySeparator: '￮',\n    storeable: true,\n    searchable: true,\n    indexPath: 'si',\n    logLevel: 'error',\n    nGramLength: 1,\n    nGramSeparator: ' ',\n    separator: /\\s|\\\\n|\\\\u0003|[-.,<>]/,\n    stopwords: [],\n    weight: 0\n  }, options)\n  options.log = bunyan.createLogger({\n    name: 'search-index',\n    level: options.logLevel\n  })\n  if (!options.indexes) {\n    levelup(options.indexPath || 'si', {\n      valueEncoding: 'json',\n      db: leveldown\n    }, function (err, db) {\n      options.indexes = db\n      done(err, options)\n    })\n  } else {\n    done(null, options)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-adder/lib/delete.js":"// deletes all references to a document from the search index\n\nconst util = require('util')\nconst Transform = require('stream').Transform\n\n// Remove all keys in DB\nexports.flush = function (options, callback) {\n  const sep = options.keySeparator\n  var deleteOps = []\n  options.indexes.createKeyStream({gte: '0', lte: sep})\n    .on('data', function (data) {\n      deleteOps.push({type: 'del', key: data})\n    })\n    .on('error', function (err) {\n      options.log.error(err, ' failed to empty index')\n      return callback(err)\n    })\n    .on('end', function () {\n      options.indexes.batch(deleteOps, callback)\n    })\n}\n\nconst DocVector = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.DocVector = DocVector\nutil.inherits(DocVector, Transform)\nDocVector.prototype._transform = function (docId, encoding, end) {\n  docId = JSON.parse(docId)\n  const sep = this.options.keySeparator\n  var that = this\n  this.options.indexes.createReadStream({\n    gte: 'DOCUMENT-VECTOR' + sep + docId + sep,\n    lte: 'DOCUMENT-VECTOR' + sep + docId + sep + sep\n  }).on('data', function (data) {\n    that.push(data)\n  }).on('close', function () {\n    return end()\n  })\n}\n\nconst DBEntries = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.DBEntries = DBEntries\nutil.inherits(DBEntries, Transform)\nDBEntries.prototype._transform = function (vector, encoding, end) {\n  const sep = this.options.keySeparator\n  var docId\n  for (var k in vector.value) {\n    docId = vector.key.split(sep)[1]\n    var field = vector.key.split(sep)[2]\n    this.push({\n      key: 'TF' + sep + field + sep + k,\n      value: docId\n    })\n    this.push({\n      key: 'DF' + sep + field + sep + k,\n      value: docId\n    })\n  }\n  this.push({key: vector.key})\n  this.push({key: 'DOCUMENT' + sep + docId + sep})\n\n  // TODO: fix this!\n  // this.push({key: 'DOCUMENT-COUNT'})\n  return end()\n}\n\nconst RecalibrateDB = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.RecalibrateDB = RecalibrateDB\nutil.inherits(RecalibrateDB, Transform)\nRecalibrateDB.prototype._transform = function (dbEntry, encoding, end) {\n  const sep = this.options.keySeparator\n  var that = this\n  this.options.indexes.get(dbEntry.key, function (err, value) {\n    if (err) {\n      that.options.log.info(err)\n    }\n    // handle errors better\n    if (!value) value = []\n    var docId = dbEntry.value\n    var dbInstruction = {}\n    dbInstruction.key = dbEntry.key\n    if (dbEntry.key.substring(0, 3) === 'TF' + sep) {\n      dbInstruction.value = value.filter(function (item) {\n        return (item[1] !== docId)\n      })\n      if (dbInstruction.value.length === 0) {\n        dbInstruction.type = 'del'\n      } else {\n        dbInstruction.type = 'put'\n      }\n    } else if (dbEntry.key.substring(0, 3) === 'DF' + sep) {\n      value.splice(value.indexOf(docId), 1)\n      dbInstruction.value = value\n      if (dbInstruction.value.length === 0) {\n        dbInstruction.type = 'del'\n      } else {\n        dbInstruction.type = 'put'\n      }\n    } else if (dbEntry.key.substring(0, 9) === 'DOCUMENT' + sep) {\n      dbInstruction.type = 'del'\n    } else if (dbEntry.key.substring(0, 16) === 'DOCUMENT-VECTOR' + sep) {\n      dbInstruction.type = 'del'\n    }\n    that.options.indexes.batch([dbInstruction], function (err) {\n      if (err) {\n        // then what?\n      }\n      return end()\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-adder/lib/replicate.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst DBWriteMergeStream = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.DBWriteMergeStream = DBWriteMergeStream\nutil.inherits(DBWriteMergeStream, Transform)\nDBWriteMergeStream.prototype._transform = function (data, encoding, end) {\n  if (data.totalKeys) {\n    this.push(data)\n    return end()\n  }\n  const sep = this.options.keySeparator\n  var that = this\n  this.options.indexes.get(data.key, function (err, val) {\n    err // do something with this error\n    var newVal\n    // concat to existing values (only if they exist)\n    if (data.key.substring(0, 3) === 'TF' + sep) {\n      // sort first on magnitude then on ID\n      newVal = data.value.concat(val || []).sort(function (a, b) {\n        if (a[0] === b[0]) return b[1] - a[1]\n        else return b[0] - a[0]\n      })\n    } else if (data.key.substring(0, 3) === 'DF' + sep) {\n      newVal = data.value.concat(val || []).sort()\n    } else if (data.key === 'DOCUMENT-COUNT') {\n      newVal = (+val) + (+data.value || 0)\n    } else {\n      newVal = data.value\n    }\n    that.options.indexes.put(data.key, newVal, function (err) {\n      err // do something with this error\n      that.push(data)\n      end()\n    })\n  })\n}\n\nconst DBWriteCleanStream = function (options) {\n  this.currentBatch = []\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nutil.inherits(DBWriteCleanStream, Transform)\nDBWriteCleanStream.prototype._transform = function (data, encoding, end) {\n  var that = this\n  this.currentBatch.push(data)\n  if (this.currentBatch.length % this.options.batchSize === 0) {\n    this.options.indexes.batch(this.currentBatch, function (err) {\n      // TODO: some nice error handling if things go wrong\n      err\n      that.push('indexing batch')\n      that.currentBatch = [] // reset batch\n      end()\n    })\n  } else {\n    end()\n  }\n}\nDBWriteCleanStream.prototype._flush = function (end) {\n  var that = this\n  this.options.indexes.batch(this.currentBatch, function (err) {\n    // TODO: some nice error handling if things go wrong\n    err\n    that.push('remaining data indexed')\n    end()\n  })\n}\nexports.DBWriteCleanStream = DBWriteCleanStream\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-adder/lib/add.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst emitIndexKeys = function (s) {\n  for (var key in s.deltaIndex) {\n    s.push({\n      key: key,\n      value: s.deltaIndex[key]\n    })\n  }\n  s.deltaIndex = {}\n}\n\nconst IndexBatch = function (indexer) {\n  this.indexer = indexer\n  this.deltaIndex = {}\n  Transform.call(this, { objectMode: true })\n}\nexports.IndexBatch = IndexBatch\nutil.inherits(IndexBatch, Transform)\nIndexBatch.prototype._transform = function (ingestedDoc, encoding, end) {\n  const sep = this.indexer.options.keySeparator\n  var that = this\n  this.indexer.deleter([ingestedDoc.id], function (err) {\n    if (err) that.indexer.log.info(err)\n    that.indexer.options.log.info('processing doc ' + ingestedDoc.id)\n    that.deltaIndex['DOCUMENT' + sep + ingestedDoc.id + sep] = ingestedDoc.stored\n    for (var fieldName in ingestedDoc.vector) {\n      that.deltaIndex['FIELD' + sep + fieldName] = fieldName\n      for (var token in ingestedDoc.vector[fieldName]) {\n        var vMagnitude = ingestedDoc.vector[fieldName][token]\n        var tfKeyName = 'TF' + sep + fieldName + sep + token\n        var dfKeyName = 'DF' + sep + fieldName + sep + token\n        that.deltaIndex[tfKeyName] = that.deltaIndex[tfKeyName] || []\n        that.deltaIndex[tfKeyName].push([vMagnitude, ingestedDoc.id])\n        that.deltaIndex[dfKeyName] = that.deltaIndex[dfKeyName] || []\n        that.deltaIndex[dfKeyName].push(ingestedDoc.id)\n      }\n      that.deltaIndex['DOCUMENT-VECTOR' + sep + ingestedDoc.id + sep + fieldName + sep] =\n        ingestedDoc.vector[fieldName]\n    }\n    // console.log(Object.keys(that.deltaIndex).length)\n    // console.log(that.batchOptions.batchSize)\n    var totalKeys = Object.keys(that.deltaIndex).length\n    if (totalKeys > that.indexer.options.batchSize) {\n      that.push({totalKeys: totalKeys})\n      that.indexer.options.log.info(\n        'deltaIndex is ' + totalKeys + ' long, emitting')\n      emitIndexKeys(that)\n    }\n    return end()\n  })\n}\nIndexBatch.prototype._flush = function (end) {\n  // merge this index into main index\n  emitIndexKeys(this)\n  return end()\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/index.js":"const AvailableFields = require('./lib/AvailableFields.js').AvailableFields\nconst CalculateBuckets = require('./lib/CalculateBuckets.js').CalculateBuckets\nconst CalculateCategories = require('./lib/CalculateCategories.js').CalculateCategories\nconst CalculateEntireResultSet = require('./lib/CalculateEntireResultSet.js').CalculateEntireResultSet\nconst CalculateResultSetPerClause = require('./lib/CalculateResultSetPerClause.js').CalculateResultSetPerClause\nconst CalculateTopScoringDocs = require('./lib/CalculateTopScoringDocs.js').CalculateTopScoringDocs\nconst CalculateTotalHits = require('./lib/CalculateTotalHits.js').CalculateTotalHits\nconst Classify = require('./lib/Classify.js').Classify\nconst FetchDocsFromDB = require('./lib/FetchDocsFromDB.js').FetchDocsFromDB\nconst FetchStoredDoc = require('./lib/FetchStoredDoc.js').FetchStoredDoc\nconst GetIntersectionStream = require('./lib/GetIntersectionStream.js').GetIntersectionStream\nconst MergeOrConditions = require('./lib/MergeOrConditions.js').MergeOrConditions\nconst Readable = require('stream').Readable\nconst ScoreDocsOnField = require('./lib/ScoreDocsOnField.js').ScoreDocsOnField\nconst ScoreTopScoringDocsTFIDF = require('./lib/ScoreTopScoringDocsTFIDF.js').ScoreTopScoringDocsTFIDF\nconst SortTopScoringDocs = require('./lib/SortTopScoringDocs.js').SortTopScoringDocs\nconst bunyan = require('bunyan')\nconst levelup = require('levelup')\nconst matcher = require('./lib/matcher.js')\nconst siUtil = require('./lib/siUtil.js')\n\nconst initModule = function (err, Searcher, moduleReady) {\n  Searcher.bucketStream = function (q) {\n    q = siUtil.getQueryDefaults(q)\n    const s = new Readable({ objectMode: true })\n    q.query.forEach(function (clause) {\n      s.push(clause)\n    })\n    s.push(null)\n    return s\n      .pipe(new CalculateResultSetPerClause(Searcher.options, q.filter || {}))\n      .pipe(new CalculateEntireResultSet(Searcher.options))\n      .pipe(new CalculateBuckets(Searcher.options, q.filter || {}, q.buckets))\n  }\n\n  Searcher.categoryStream = function (q) {\n    q = siUtil.getQueryDefaults(q)\n    const s = new Readable({ objectMode: true })\n    q.query.forEach(function (clause) {\n      s.push(clause)\n    })\n    s.push(null)\n    return s\n      .pipe(new CalculateResultSetPerClause(Searcher.options, q.filter || {}))\n      .pipe(new CalculateEntireResultSet(Searcher.options))\n      .pipe(new CalculateCategories(Searcher.options, q))\n  }\n\n  Searcher.classify = function (callback) {\n    return new Classify(Searcher)\n  }\n\n  Searcher.close = function (callback) {\n    Searcher.options.indexes.close(function (err) {\n      while (!Searcher.options.indexes.isClosed()) {\n        Searcher.options.log.debug('closing...')\n      }\n      if (Searcher.options.indexes.isClosed()) {\n        Searcher.options.log.debug('closed...')\n        callback(err)\n      }\n    })\n  }\n\n  Searcher.availableFields = function () {\n    const sep = Searcher.options.keySeparator\n    return Searcher.options.indexes.createReadStream({\n      gte: 'FIELD' + sep,\n      lte: 'FIELD' + sep + sep\n    }).pipe(new AvailableFields(Searcher.options))\n  }\n\n  Searcher.get = function (docIDs) {\n    var s = new Readable({ objectMode: true })\n    docIDs.forEach(function (id) {\n      s.push(id)\n    })\n    s.push(null)\n    return s.pipe(new FetchDocsFromDB(Searcher.options))\n  }\n\n  Searcher.fieldNames = function () {\n    return Searcher.options.indexes.createReadStream({\n      gte: 'FIELD',\n      lte: 'FIELD'\n    })\n  }\n\n  Searcher.match = function (q) {\n    return matcher.match(q, Searcher.options)\n  }\n\n  Searcher.dbReadStream = function () {\n    return Searcher.options.indexes.createReadStream()\n  }\n\n  Searcher.search = function (q) {\n    q = siUtil.getQueryDefaults(q)\n    const s = new Readable({ objectMode: true })\n    q.query.forEach(function (clause) {\n      s.push(clause)\n    })\n    s.push(null)\n    if (q.sort) {\n      return s\n        .pipe(new CalculateResultSetPerClause(Searcher.options))\n        .pipe(new CalculateTopScoringDocs(Searcher.options, (q.offset + q.pageSize)))\n        .pipe(new ScoreDocsOnField(Searcher.options, (q.offset + q.pageSize), q.sort))\n        .pipe(new MergeOrConditions(q))\n        .pipe(new SortTopScoringDocs(q))\n        .pipe(new FetchStoredDoc(Searcher.options))\n    } else {\n      return s\n        .pipe(new CalculateResultSetPerClause(Searcher.options))\n        .pipe(new CalculateTopScoringDocs(Searcher.options, (q.offset + q.pageSize)))\n        .pipe(new ScoreTopScoringDocsTFIDF(Searcher.options))\n        .pipe(new MergeOrConditions(q))\n        .pipe(new SortTopScoringDocs(q))\n        .pipe(new FetchStoredDoc(Searcher.options))\n    }\n  }\n\n  // TODO: seriously needs a rewrite\n  Searcher.scan = function (q) {\n    q = siUtil.getQueryDefaults(q)\n    // just make this work for a simple one clause AND\n    // TODO: add filtering, NOTting, multi-clause AND\n    var s = new Readable({ objectMode: true })\n    s.push('init')\n    s.push(null)\n    return s\n      .pipe(new GetIntersectionStream(Searcher.options,\n                                      siUtil.getKeySet(\n                                        q.query[0].AND,\n                                        Searcher.options.keySeparator\n                                      )))\n      .pipe(new FetchDocsFromDB(Searcher.options))\n  }\n\n  Searcher.totalHits = function (q, callback) {\n    q = siUtil.getQueryDefaults(q)\n    const s = new Readable({ objectMode: true })\n    q.query.forEach(function (clause) {\n      s.push(clause)\n    })\n    s.push(null)\n    s.pipe(new CalculateResultSetPerClause(Searcher.options, q.filter || {}))\n      .pipe(new CalculateEntireResultSet(Searcher.options))\n      .pipe(new CalculateTotalHits(Searcher.options)).on('data', function (totalHits) {\n        return callback(null, totalHits)\n      })\n  }\n\n  return moduleReady(err, Searcher)\n}\n\nconst getOptions = function (options, done) {\n  var Searcher = {}\n  Searcher.options = Object.assign({}, {\n    deletable: true,\n    fieldedSearch: true,\n    store: true,\n    indexPath: 'si',\n    keySeparator: '￮',\n    logLevel: 'error',\n    nGramLength: 1,\n    nGramSeparator: ' ',\n    separator: /[|' .,\\-|(\\n)]+/,\n    stopwords: []\n  }, options)\n  Searcher.options.log = bunyan.createLogger({\n    name: 'search-index',\n    level: options.logLevel\n  })\n  if (!options.indexes) {\n    levelup(Searcher.options.indexPath || 'si', {\n      valueEncoding: 'json'\n    }, function (err, db) {\n      Searcher.options.indexes = db\n      return done(err, Searcher)\n    })\n  } else {\n    return done(null, Searcher)\n  }\n}\n\nmodule.exports = function (givenOptions, moduleReady) {\n  getOptions(givenOptions, function (err, Searcher) {\n    initModule(err, Searcher, moduleReady)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/AvailableFields.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst AvailableFields = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.AvailableFields = AvailableFields\nutil.inherits(AvailableFields, Transform)\nAvailableFields.prototype._transform = function (field, encoding, end) {\n  this.push(field.key.split(this.options.keySeparator)[1])\n  return end()\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/CalculateBuckets.js":"const _intersection = require('lodash.intersection')\nconst _uniq = require('lodash.uniq')\nconst Transform = require('stream').Transform\nconst util = require('util')\n\nconst CalculateBuckets = function (options, filter, requestedBuckets) {\n  this.buckets = requestedBuckets || []\n  this.filter = filter\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.CalculateBuckets = CalculateBuckets\nutil.inherits(CalculateBuckets, Transform)\nCalculateBuckets.prototype._transform = function (mergedQueryClauses, encoding, end) {\n  const that = this\n  const sep = this.options.keySeparator\n  var bucketsProcessed = 0\n  that.buckets.forEach(function (bucket) {\n    const gte = 'DF' + sep + bucket.field + sep + bucket.gte\n    const lte = 'DF' + sep + bucket.field + sep + bucket.lte + sep\n    that.options.indexes.createReadStream({gte: gte, lte: lte})\n      .on('data', function (data) {\n        var IDSet = _intersection(data.value, mergedQueryClauses.set)\n        if (IDSet.length > 0) {\n          bucket.value = bucket.value || []\n          bucket.value = _uniq(bucket.value.concat(IDSet).sort())\n        }\n      })\n      .on('close', function () {\n        if (!bucket.set) {\n          bucket.value = bucket.value.length\n        }\n        that.push(bucket)\n        if (++bucketsProcessed === that.buckets.length) {\n          return end()\n        }\n      })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/CalculateCategories.js":"const _intersection = require('lodash.intersection')\nconst Transform = require('stream').Transform\nconst util = require('util')\n\nconst CalculateCategories = function (options, q) {\n  var category = q.category || []\n  category.values = []  // breaky line\n  this.offset = +q.offset\n  this.pageSize = +q.pageSize\n  this.category = category\n  this.options = options\n  this.query = q.query\n  Transform.call(this, { objectMode: true })\n}\nexports.CalculateCategories = CalculateCategories\nutil.inherits(CalculateCategories, Transform)\nCalculateCategories.prototype._transform = function (mergedQueryClauses, encoding, end) {\n  if (!this.category.field) {\n    return end(new Error('you need to specify a category'))\n  }\n  const sep = this.options.keySeparator\n  const that = this\n  const gte = 'DF' + sep + this.category.field + sep\n  const lte = 'DF' + sep + this.category.field + sep + sep\n  this.category.values = this.category.values || []\n  var i = this.offset + this.pageSize\n  var j = 0\n  const rs = that.options.indexes.createReadStream({gte: gte, lte: lte})\n  rs.on('data', function (data) {\n    // page not yet reached\n    if (that.offset > j++) return\n    var IDSet = _intersection(data.value, mergedQueryClauses.set)\n    if (IDSet.length > 0) { // make this optional\n      var key = data.key.split(sep)[2]\n      var value = IDSet.length\n      if (that.category.set) {\n        value = IDSet\n      }\n      var result = {\n        key: key,\n        value: value\n      }\n      // set filter: true on queries with a single OR clause\n      if (that.query.length === 1) {\n        try {\n          if (that.query[0].AND[that.category.field].indexOf(key) > -1) {\n            result.filter = true\n          }\n        } catch (e) {}\n      }\n      // page size exceeded\n      if (i-- > that.offset) {\n        that.push(result)\n      } else {\n        rs.destroy()\n      }\n    }\n  }).on('close', function () {\n    return end()\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/CalculateEntireResultSet.js":"const Transform = require('stream').Transform\nconst _union = require('lodash.union')\nconst util = require('util')\n\nconst CalculateEntireResultSet = function (options) {\n  this.options = options\n  this.setSoFar = []\n  Transform.call(this, { objectMode: true })\n}\nexports.CalculateEntireResultSet = CalculateEntireResultSet\nutil.inherits(CalculateEntireResultSet, Transform)\nCalculateEntireResultSet.prototype._transform = function (queryClause, encoding, end) {\n  this.setSoFar = _union(queryClause.set, this.setSoFar)\n  return end()\n}\nCalculateEntireResultSet.prototype._flush = function (end) {\n  this.push({\n    set: this.setSoFar\n  })\n  return end()\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/CalculateResultSetPerClause.js":"const Transform = require('stream').Transform\nconst _difference = require('lodash.difference')\nconst _intersection = require('lodash.intersection')\nconst _spread = require('lodash.spread')\nconst siUtil = require('./siUtil.js')\nconst util = require('util')\n\nconst CalculateResultSetPerClause = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.CalculateResultSetPerClause = CalculateResultSetPerClause\nutil.inherits(CalculateResultSetPerClause, Transform)\nCalculateResultSetPerClause.prototype._transform = function (queryClause, encoding, end) {\n  const sep = this.options.keySeparator\n  const that = this\n  const frequencies = []\n  var NOT = function (includeResults) {\n    const bigIntersect = _spread(_intersection)\n    var include = bigIntersect(includeResults)\n    // if there are no NOT conditions, simply end()\n    if (siUtil.getKeySet(queryClause.NOT, sep).length === 0) {\n      that.push({\n        queryClause: queryClause,\n        set: include,\n        termFrequencies: frequencies,\n        BOOST: queryClause.BOOST || 0\n      })\n      return end()\n    } else {\n      // if there ARE \"NOT\"-conditions, remove all IDs specified by NOT\n      var i = 0\n      var excludeResults = []\n      siUtil.getKeySet(queryClause.NOT, sep).forEach(function (item) {\n        var excludeSet = {}\n        that.options.indexes.createReadStream({gte: item[0], lte: item[1] + sep})\n          .on('data', function (data) {\n            for (var i = 0; i < data.value.length; i++) {\n              excludeSet[data.value[i]] = 1\n            }\n          })\n          .on('error', function (err) {\n            that.options.log.debug(err)\n          })\n          .on('end', function () {\n            var exclude = Object.keys(excludeSet)\n            excludeResults.push(exclude.sort())\n            if (++i === siUtil.getKeySet(queryClause.NOT, sep).length) {\n              excludeResults.forEach(function (excludeSet) {\n                include = _difference(include, excludeSet)\n              })\n              that.push({\n                queryClause: queryClause,\n                set: include,\n                termFrequencies: frequencies,\n                BOOST: queryClause.BOOST || 0\n              })\n              return end()\n            }\n          })\n      })\n    }\n  }\n  // Get all of the IDs in the AND conditions\n  var IDSets = []\n  siUtil.getKeySet(queryClause.AND, sep).forEach(function (item) {\n    var includeSet = {}\n    var setLength = 0\n    that.options.indexes.createReadStream({gte: item[0], lte: item[1]})\n      .on('data', function (data) {\n        setLength += data.value.length\n        for (var i = 0; i < data.value.length; i++) {\n          includeSet[data.value[i]] = 1\n        }\n      })\n      .on('error', function (err) {\n        that.options.log.debug(err)\n      })\n      .on('end', function () {\n        var include = Object.keys(includeSet)\n        frequencies.push({\n          gte: item[0].split(sep)[1] + sep + item[0].split(sep)[2],\n          lte: item[1].split(sep)[1] + sep + item[1].split(sep)[2],\n          tf: include.length, // actual term frequency across docs\n          setLength: setLength // number of array elements that need to be traversed\n        })\n        IDSets.push(include.sort())\n        if (IDSets.length === siUtil.getKeySet(queryClause.AND, sep).length) {\n          NOT(IDSets)\n        }\n      })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/siUtil.js":"exports.getKeySet = function (clause, sep) {\n  var keySet = []\n  for (var fieldName in clause) {\n    clause[fieldName].forEach(function (token) {\n      var gte = token.gte || token\n      var lte = token.lte || token\n      keySet.push([\n        'DF' + sep + fieldName + sep + gte,\n        'DF' + sep + fieldName + sep + lte\n      ])\n    })\n  }\n  return keySet\n}\n\nexports.getQueryDefaults = function (q) {\n  // if a string is given- turn it into a query\n  if (typeof q === 'string') {\n    q = {\n      query: [{\n        AND: {'*': q.split(' ')}\n      }]\n    }\n  }\n  // Make sure that user query is arrayified\n  if (q) {\n    if (q.query) {\n      if (Object.prototype.toString.call(q.query) !== '[object Array]') {\n        q.query = [q.query]\n      }\n    }\n  }\n  // cast strings to int, where possible (\"2\" = 2)\n  try {\n    if (q.offset) q.offset = parseInt(q.offset)\n  } catch (e) {}\n  try {\n    if (q.pageSize) q.pageSize = parseInt(q.pageSize)\n  } catch (e) {}\n  return Object.assign({}, {\n    query: [{\n      AND: {'*': ['*']}\n    }],\n    offset: 0,\n    pageSize: 20\n  }, q)\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/CalculateTopScoringDocs.js":"const Transform = require('stream').Transform\nconst _sortedIndexOf = require('lodash.sortedindexof')\nconst util = require('util')\n\nconst CalculateTopScoringDocs = function (options, seekLimit) {\n  this.options = options\n  this.seekLimit = seekLimit\n  Transform.call(this, { objectMode: true })\n}\nexports.CalculateTopScoringDocs = CalculateTopScoringDocs\nutil.inherits(CalculateTopScoringDocs, Transform)\nCalculateTopScoringDocs.prototype._transform = function (clauseSet, encoding, end) {\n  const sep = this.options.keySeparator\n  // clauseSet = JSON.parse(clauseSet)\n  const that = this\n\n  const lowestFrequency = clauseSet.termFrequencies.sort(function (a, b) {\n    return a.setLength - b.setLength\n  })[0]\n\n  const gte = 'TF' + sep + lowestFrequency.gte\n  const lte = 'TF' + sep + lowestFrequency.lte + sep\n\n  // walk down the DF array of lowest frequency hit until (offset +\n  // pagesize) hits have been found\n\n  var topScoringDocs = []\n  that.options.indexes.createReadStream({gte: gte, lte: lte})\n    .on('data', function (data) {\n      var intersections = []\n      // Do intersection and pagination cutoffs here- only push\n      // results that are in the resultset\n      for (var i = 0\n        ; ((i < data.value.length) && (intersections.length < that.seekLimit)); i++) {\n        if (_sortedIndexOf(clauseSet.set, data.value[i][1]) !== -1) {\n          intersections.push(data.value[i])\n        }\n      }\n      topScoringDocs = topScoringDocs.concat(intersections)\n    })\n    .on('error', function (err) {\n      that.options.log.debug(err)\n    })\n    .on('end', function () {\n      // fetch document vectors for the highest scores and work out\n      // complete score for each selected doc.\n      clauseSet['topScoringDocs'] = topScoringDocs\n      that.push(clauseSet)\n      return end()\n    })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/CalculateTotalHits.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst CalculateTotalHits = function (options, filter, requestedBuckets) {\n  this.buckets = requestedBuckets || []\n  this.filter = filter\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.CalculateTotalHits = CalculateTotalHits\nutil.inherits(CalculateTotalHits, Transform)\nCalculateTotalHits.prototype._transform = function (mergedQueryClauses, encoding, end) {\n  this.push(mergedQueryClauses.set.length)\n  end()\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/Classify.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst Classify = function (searcher) {\n  this.options = searcher.options || {}\n  this.match = searcher.match\n  this.nGramLength = this.options.nGramLength.lte || 1\n  this.stack = []\n  Transform.call(this, { objectMode: true })\n}\nexports.Classify = Classify\nutil.inherits(Classify, Transform)\nClassify.prototype._transform = function (token, encoding, end) {\n  var stack = this.stack\n  var t = token.toString()\n  var that = this\n  var potentialMatches = []\n  stack.push(t)\n  if (stack.length < this.nGramLength) return end()\n  stack.forEach(function (item, i) {\n    potentialMatches.push(stack.slice(0, (1 + i)).join(' ').toLowerCase())\n  })\n  var counter = 0\n  potentialMatches.forEach(function (item) {\n    that.match({\n      beginsWith: item,\n      type: 'ID',\n      limit: 1\n    }).on('data', function (match) {\n      if (match.token === item) { that.push(match) }\n    }).on('end', function () {\n      if (++counter === potentialMatches.length) {\n        stack.shift()\n        return end()\n      }\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/FetchDocsFromDB.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst FetchDocsFromDB = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.FetchDocsFromDB = FetchDocsFromDB\nutil.inherits(FetchDocsFromDB, Transform)\nFetchDocsFromDB.prototype._transform = function (line, encoding, end) {\n  const sep = this.options.keySeparator\n  const that = this\n  this.options.indexes.get('DOCUMENT' + sep + line.toString() + sep, function (err, doc) {\n    if (!err) {\n      that.push(doc)\n    }\n    end()\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/FetchStoredDoc.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst FetchStoredDoc = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.FetchStoredDoc = FetchStoredDoc\nutil.inherits(FetchStoredDoc, Transform)\nFetchStoredDoc.prototype._transform = function (doc, encoding, end) {\n  const sep = this.options.keySeparator\n  var that = this\n  // doc = JSON.parse(doc)\n  that.options.indexes.get('DOCUMENT' + sep + doc.id + sep, function (err, stored) {\n    if (err) {\n      that.options.log.debug(err)\n    }\n    doc.document = stored\n    that.push(doc)\n    return end()\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/GetIntersectionStream.js":"const Transform = require('stream').Transform\nconst iats = require('intersect-arrays-to-stream')\nconst util = require('util')\n\n// Make a Transform stream stage to get an intersection stream\nconst GetIntersectionStream = function (options, ANDKeys) {\n  this.ANDKeys = ANDKeys\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.GetIntersectionStream = GetIntersectionStream\nutil.inherits(GetIntersectionStream, Transform)\nGetIntersectionStream.prototype._transform = function (line, encoding, end) {\n  const that = this\n  var IDSets = []\n  this.ANDKeys.forEach(function (item) {\n    var ANDSetIDs = []\n    that.options.indexes.createReadStream({gte: item[0], lte: item[1]})\n      .on('data', function (data) {\n        ANDSetIDs = ANDSetIDs.concat(data.value).sort()\n      })\n      .on('end', function () {\n        IDSets.push(ANDSetIDs)\n        if (IDSets.length === that.ANDKeys.length) {\n          iats.getIntersectionStream(IDSets).on('data', function (data) {\n            that.push(data)\n          }).on('end', function () {\n            end()\n          })\n        }\n      })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/MergeOrConditions.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst MergeOrConditions = function (q) {\n  this.resultSet = []\n  this.q = q\n  Transform.call(this, { objectMode: true })\n}\nexports.MergeOrConditions = MergeOrConditions\nutil.inherits(MergeOrConditions, Transform)\nMergeOrConditions.prototype._transform = function (doc, encoding, end) {\n  // console.log(JSON.stringify(doc, null, 2))\n  this.resultSet.push(doc)\n  return end()\n}\nMergeOrConditions.prototype._flush = function (end) {\n  var that = this\n  // get rid of OR conditions- merge on doc id\n  var mergedResultSet = this.resultSet.sort(function (a, b) {\n    if (a.id < b.id) return 1\n    if (a.id > b.id) return -1\n    return 0\n  }).reduce(function (merged, cur) {\n    // merge scoring criteria (OR conditions)\n    var lastDoc = merged[merged.length - 1]\n    if (merged.length === 0 || (cur.id !== lastDoc.id)) {\n      merged.push(cur)\n    } else if (cur.id === lastDoc.id) {\n      // in case a document is duplicated with different score, save the higher score\n      lastDoc.scoringCriteria = lastDoc.scoringCriteria.concat(cur.scoringCriteria)\n    }\n    return merged\n  }, [])\n\n  // console.log(JSON.stringify(mergedResultSet, null, 2))\n\n  // work out the score as an average of all OR conditions.\n  mergedResultSet.map(function (item) {\n    // sum up score\n\n    if (item.scoringCriteria) {\n      item.score = item.scoringCriteria.reduce(function (acc, val) {\n        return { score: +acc.score + +val.score }\n      }, { score: 0 }).score\n\n      // TODO: possible to score multiple OR conditions by an AVERAGE, or a SUM\n\n      // work out average score (score divided by total OR conditions)\n      item.score = (item.score / item.scoringCriteria.length)\n    }\n\n    return item\n  })\n\n  // console.log(JSON.stringify(mergedResultSet, null, 2))\n\n  mergedResultSet.forEach(function (item) {\n    that.push(item)\n  })\n  return end()\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/ScoreDocsOnField.js":"const Transform = require('stream').Transform\nconst _sortedIndexOf = require('lodash.sortedindexof')\nconst util = require('util')\n\nconst ScoreDocsOnField = function (options, seekLimit, sort) {\n  this.options = options\n  this.seekLimit = seekLimit\n  this.sort = sort\n  Transform.call(this, { objectMode: true })\n}\nexports.ScoreDocsOnField = ScoreDocsOnField\nutil.inherits(ScoreDocsOnField, Transform)\nScoreDocsOnField.prototype._transform = function (clauseSet, encoding, end) {\n  const sep = this.options.keySeparator\n  // clauseSet = JSON.parse(clauseSet)\n  const that = this\n\n  const gte = 'TF' + sep + this.sort.field + sep\n  const lte = 'TF' + sep + this.sort.field + sep + sep\n\n  // walk down the DF array of lowest frequency hit until (offset +\n  // pagesize) hits have been found\n  that.options.indexes.createReadStream({gte: gte, lte: lte})\n    .on('data', function (data) {\n      for (var i = 0; ((i < data.value.length) && (i < that.seekLimit)); i++) {\n        if (_sortedIndexOf(clauseSet.set, data.value[i][1]) !== -1) {\n          that.push({\n            id: data.value[i][1],\n            score: data.value[i][0]\n          })\n        }\n      }\n    })\n    .on('end', function () {\n      return end()\n    })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/ScoreTopScoringDocsTFIDF.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst ScoreTopScoringDocsTFIDF = function (options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nexports.ScoreTopScoringDocsTFIDF = ScoreTopScoringDocsTFIDF\nutil.inherits(ScoreTopScoringDocsTFIDF, Transform)\nScoreTopScoringDocsTFIDF.prototype._transform = function (clause, encoding, end) {\n  const sep = this.options.keySeparator\n  const that = this\n  clause.queryClause.BOOST = clause.queryClause.BOOST || 0 // put this somewhere better\n  const fields = Object.keys(clause.queryClause.AND)\n  var i = 0\n  // async.each(clause.topScoringDocs, function (docID, nextDocCallback) {\n\n  // if there are no docs, just return\n  if (clause.topScoringDocs.length === 0) return end()\n\n  clause.topScoringDocs.forEach(function (docID) {\n    docID = docID[1]\n    // var vectors = []\n    var tfVectors = {}\n    // for each field in query:\n    var fieldFetchCounter = 0\n    fields.forEach(function (field) {\n      // get vector for whole document field\n      that.options.indexes.get(\n        'DOCUMENT-VECTOR' + sep + docID + sep + field + sep, function (err, docVector) {\n          if (err) console.log(err) // TODO something clever with err\n          // const vector = {}\n          clause.queryClause.AND[field].forEach(function (token) {\n            tfVectors[field + sep + token] = docVector[token]\n          })\n          // How to recognise last field?\n          if (++fieldFetchCounter === fields.length) {\n            var documentFrequencies = clause.termFrequencies\n            // All vectors loaded from index: work out score\n            // At this stage documents are scores per clause- the clauses are merged later\n            // Work out tfidf per field/token\n            const tfidf = {}\n            for (var j = 0; j <= documentFrequencies.length; j++) {\n              var item = documentFrequencies[j]\n              if (!item) continue\n              var tf = +item.tf\n              var df = +tfVectors[item.gte] // should this be gte?\n              var idf = Math.log10(1 + (1 / df))\n              tfidf[item.gte] = (tf * idf)\n            }\n\n            // Work out tfidf per clause\n            var score = (Object.keys(tfidf).reduce(function (prev, cur) {\n              return (tfidf[prev] || 0) + tfidf[cur]\n            }, 0) / Object.keys(tfidf).length)\n\n            that.push({\n              id: docID,\n              scoringCriteria: [{\n                tf: tfVectors,\n                df: documentFrequencies,\n                tfidf: tfidf,\n                boost: +clause.queryClause.BOOST,\n                score: score - +clause.queryClause.BOOST\n              }],\n              score: score - +clause.queryClause.BOOST\n            })\n\n            if (++i === clause.topScoringDocs.length) {\n              return end()\n            }\n          }\n        })\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/SortTopScoringDocs.js":"const Transform = require('stream').Transform\nconst util = require('util')\n\nconst SortTopScoringDocs = function (q) {\n  this.resultSet = []\n  this.q = q\n  if (q.sort) {\n    if (q.sort.direction) {\n      this.sortDirection = q.sort.direction\n    }\n  }\n  Transform.call(this, { objectMode: true })\n}\nexports.SortTopScoringDocs = SortTopScoringDocs\nutil.inherits(SortTopScoringDocs, Transform)\nSortTopScoringDocs.prototype._transform = function (doc, encoding, end) {\n  this.resultSet.push(doc)\n  return end()\n}\nSortTopScoringDocs.prototype._flush = function (end) {\n  const that = this\n  if (this.sortDirection === 'desc') {\n    this.resultSet = this.resultSet.sort(function (a, b) {\n      if (a.score < b.score) return 2\n      if (a.score > b.score) return -2\n      if (a.id < b.id) return 1\n      if (a.id > b.id) return -1\n      return 0\n    })\n  } else {\n    this.resultSet = this.resultSet.sort(function (a, b) {\n      if (a.score > b.score) return 2\n      if (a.score < b.score) return -2\n      if (a.id < b.id) return 1\n      if (a.id > b.id) return -1\n      return 0\n    })\n  }\n  this.resultSet = this.resultSet.slice(this.q.offset, this.q.offset + this.q.pageSize)\n  this.resultSet.forEach(function (hit) {\n    that.push(hit)\n  })\n  return end()\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index-searcher/lib/matcher.js":"const Readable = require('stream').Readable\nconst Transform = require('stream').Transform\nconst util = require('util')\n\nconst MatcherStream = function (q, options) {\n  this.options = options\n  Transform.call(this, { objectMode: true })\n}\nutil.inherits(MatcherStream, Transform)\nMatcherStream.prototype._transform = function (q, encoding, end) {\n  const sep = this.options.keySeparator\n  const that = this\n  var results = []\n  this.options.indexes.createReadStream({\n    start: 'DF' + sep + q.field + sep + q.beginsWith,\n    end: 'DF' + sep + q.field + sep + q.beginsWith + sep\n  })\n  .on('data', function (data) {\n    results.push(data)\n  })\n  .on('error', function (err) {\n    that.options.log.error('Oh my!', err)\n  })\n  // .on('end', sortResults)\n  .on('end', function () {\n    results.sort(function (a, b) {\n      return b.value.length - a.value.length\n    })\n      .slice(0, q.limit)\n      .forEach(function (item) {\n        var m = {}\n        switch (q.type) {\n          case 'ID': m = {\n            token: item.key.split(sep)[2],\n            documents: item.value\n          }; break\n          case 'count': m = {\n            token: item.key.split(sep)[2],\n            documentCount: item.value.length\n          }; break\n          default: m = item.key.split(sep)[2]\n        }\n        that.push(m)\n      })\n    return end()\n  })\n}\n\nexports.match = function (q, options) {\n  var s = new Readable({ objectMode: true })\n  q = Object.assign({}, {\n    beginsWith: '',\n    field: '*',\n    threshold: 3,\n    limit: 10,\n    type: 'simple'\n  }, q)\n  if (q.beginsWith.length < q.threshold) {\n    s.push(null)\n    return s\n  }\n  s.push(q)\n  s.push(null)\n\n  return s.pipe(new MatcherStream(q, options))\n}\n","/home/travis/build/npmtest/node-npmtest-search-index/node_modules/search-index/lib/siUtil.js":"module.exports = function(siOptions) {\n  var siUtil = {}\n\n  siUtil.countDocs = function (callback) {\n    var count = 0\n    const gte = 'DOCUMENT' + siOptions.keySeparator\n    const lte = 'DOCUMENT' + siOptions.keySeparator + siOptions.keySeparator\n    siOptions.indexes.createReadStream({gte: gte, lte: lte})\n      .on('data', function (data) {\n        count++\n      })\n      .on('error', function (err) {\n        return callback(err, null)\n      })\n      .on('end', function () {\n        return callback(null, count)\n      })\n  }\n\n  siUtil.close = function (callback) {\n    siOptions.indexes.close(function (err) {\n      while (!siOptions.indexes.isClosed()) {\n        //log not always working here- investigate\n        if (siOptions.log) siOptions.log.info('closing...')\n      }\n      if (siOptions.indexes.isClosed()) {\n        if (siOptions.log) siOptions.log.info('closed...')\n        callback(err)\n      }\n    })\n  }\n\n  return siUtil\n}\n"}